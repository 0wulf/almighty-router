#!/usr/bin/env bash
set -euo pipefail

# Raspberry Pi OS Lite
# WiFi AP + NAT gateway
# Pi-hole FTL (Docker, host network) provides DNS + DHCP

REPO_DIR="$(cd "$(dirname "$0")" && pwd)"
ENV_FILE="$REPO_DIR/.env"

if [[ "$EUID" -ne 0 ]]; then
  echo "[!] Run as root" >&2
  exit 1
fi

if [[ ! -f "$ENV_FILE" ]]; then
  echo "[!] Missing .env file" >&2
  exit 1
fi

# shellcheck disable=SC1090
source "$ENV_FILE"

log() { echo "[+] $*"; }

########################################
# Base packages
########################################
APT_PKGS=(
  curl ca-certificates gnupg lsb-release
  nftables iproute2 net-tools
  dhcpcd5 hostapd
  isc-dhcp-server
)

########################################
# Disable conflicting services
########################################
disable_conflicting_services() {
  log "Disabling conflicting services"
  systemctl stop systemd-resolved || true
  systemctl disable systemd-resolved || true
  systemctl stop dnsmasq || true
  systemctl disable dnsmasq || true
  systemctl stop wpa_supplicant@wlan0 || true
  systemctl disable wpa_supplicant@wlan0 || true
}

########################################
# Install packages
########################################
install_packages() {
  log "Installing system packages"
  apt-get update -y
  apt-get upgrade -y
  apt-get install -y "${APT_PKGS[@]}"
}

########################################
# Docker
########################################
install_docker() {
  if ! command -v docker >/dev/null 2>&1; then
    log "Installing Docker"
    curl -fsSL https://get.docker.com | sh
  fi
  apt-get install -y docker-compose-plugin
  systemctl enable docker
  systemctl restart docker
}

########################################
# Kernel routing
########################################
enable_ip_forwarding() {
  log "Enabling IPv4 forwarding"
  cat >/etc/sysctl.d/99-router.conf <<EOF
net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=0
EOF
  sysctl --system
}

########################################
# dhcpcd (static IP for AP)
########################################
configure_dhcpcd() {
  log "Configuring static IP for ${LAN_IFACE}"

  sed -i "/^interface ${LAN_IFACE}/,/^$/d" /etc/dhcpcd.conf

  # Extract prefix from LAN_CIDR (e.g. 192.168.50.0/24 -> 24)
  LAN_PREFIX="${LAN_CIDR##*/}"
  if [[ -z "${LAN_PREFIX:-}" ]]; then
    LAN_PREFIX=24
  fi

  # Prefer Pi-hole (running on the AP) as the resolver, fall back to configured upstreams
  DNS_SERVERS=("${LAN_GW_IP}")
  if [[ -n "${PIHOLE_DNS1:-}" ]]; then
    DNS_SERVERS+=("${PIHOLE_DNS1}")
  fi
  if [[ -n "${PIHOLE_DNS2:-}" ]]; then
    DNS_SERVERS+=("${PIHOLE_DNS2}")
  fi

  cat >> /etc/dhcpcd.conf <<EOF

interface ${LAN_IFACE}
static ip_address=${LAN_GW_IP}/${LAN_PREFIX}
static domain_name_servers=$(IFS=' '; echo "${DNS_SERVERS[*]}")
nohook wpa_supplicant
EOF

  systemctl enable dhcpcd
  systemctl restart dhcpcd
}

########################################
# Validate environment and write Pi-hole DHCP config
########################################
validate_env() {
  log "Validating required environment variables"

  local missing=0
  for v in LAN_IFACE LAN_GW_IP LAN_CIDR LAN_DHCP_START LAN_DHCP_END LAN_DHCP_LEASE PIHOLE_TIMEZONE WAN_IFACE; do
    if [[ -z "${!v:-}" ]]; then
      echo "[!] Missing env var: $v" >&2
      missing=1
    fi
  done

  if [[ $missing -eq 1 ]]; then
    echo "[!] One or more required environment variables are missing. See example.env" >&2
    exit 1
  fi
}

configure_host_dhcp() {
  log "Configuring host DHCP server (isc-dhcp-server)"

  # parse prefix and net address
  local cidr="${LAN_CIDR}"
  local net_addr="${cidr%%/*}"
  local prefix="${cidr##*/}"

  # convert prefix to netmask (supports common /24, /16, /8)
  local netmask="255.255.255.0"
  case "$prefix" in
    8) netmask=255.0.0.0 ;;
    16) netmask=255.255.0.0 ;;
    24) netmask=255.255.255.0 ;;
    *)
      # fallback: try to compute basic netmask for 24-style networks
      netmask=255.255.255.0
      ;;
  esac

  # compute lease times in seconds (support suffix h,m,s)
  local lease_raw="${LAN_DHCP_LEASE:-12h}"
  local lease_seconds=3600
  if [[ "$lease_raw" =~ ^([0-9]+)h$ ]]; then
    lease_seconds=$(( ${BASH_REMATCH[1]} * 3600 ))
  elif [[ "$lease_raw" =~ ^([0-9]+)m$ ]]; then
    lease_seconds=$(( ${BASH_REMATCH[1]} * 60 ))
  elif [[ "$lease_raw" =~ ^([0-9]+)s$ ]]; then
    lease_seconds=${BASH_REMATCH[1]}
  else
    # try plain number (seconds)
    if [[ "$lease_raw" =~ ^[0-9]+$ ]]; then
      lease_seconds=$lease_raw
    else
      lease_seconds=43200
    fi
  fi

  # Write dhcpd.conf
  cat >/etc/dhcp/dhcpd.conf <<EOF
# Generated by install.sh
default-lease-time ${lease_seconds};
max-lease-time ${lease_seconds};

subnet ${net_addr} netmask ${netmask} {
  range ${LAN_DHCP_START} ${LAN_DHCP_END};
  option routers ${LAN_GW_IP};
  option domain-name-servers ${LAN_GW_IP};
}
EOF

  # configure which interface isc-dhcp-server listens on
  if [[ -f /etc/default/isc-dhcp-server ]]; then
    sed -i "s|^INTERFACESv4=.*|INTERFACESv4=\"${LAN_IFACE}\"|" /etc/default/isc-dhcp-server || \
      echo "INTERFACESv4=\"${LAN_IFACE}\"" >> /etc/default/isc-dhcp-server
  else
    echo "INTERFACESv4=\"${LAN_IFACE}\"" > /etc/default/isc-dhcp-server
  fi

  systemctl enable isc-dhcp-server
  systemctl restart isc-dhcp-server
  log "Host DHCP configured and service restarted"
}

########################################
# RF-kill Unblocking with Retry
########################################
unblock_rfkill() {
  log "Checking and unblocking RF-kill if necessary"

  # Check if the wireless interface is soft blocked
  if rfkill list | grep -q "Soft blocked: yes"; then
    log "Unblocking wireless interface via RF-kill"
    rfkill unblock wifi
  fi

  # Retry bringing the wireless interface up
  local retries=3
  while [[ $retries -gt 0 ]]; do
    if ip link set "${LAN_IFACE}" up; then
      log "Wireless interface ${LAN_IFACE} is up"
      return
    else
      log "Failed to bring up ${LAN_IFACE}, retrying..."
      ((retries--))
      sleep 2
    fi
  done

  log "ERROR: Unable to bring up ${LAN_IFACE} after multiple attempts"
  exit 1
}

########################################
# hostapd
########################################
configure_hostapd() {
  log "Configuring hostapd"

  unblock_rfkill  # Ensure RF-kill does not block the interface

  systemctl unmask hostapd || true

  cat >/etc/hostapd/hostapd.conf <<EOF
country_code=${WIFI_COUNTRY}
interface=${LAN_IFACE}
driver=nl80211
ssid=${WIFI_SSID}
hw_mode=g
channel=${WIFI_CHANNEL}
ieee80211n=1
wmm_enabled=1
auth_algs=1
ignore_broadcast_ssid=0

wpa=2
wpa_passphrase=${WIFI_PASSWORD}
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
EOF

  sed -i 's|#DAEMON_CONF=.*|DAEMON_CONF="/etc/hostapd/hostapd.conf"|' \
    /etc/default/hostapd

  mkdir -p /etc/systemd/system/hostapd.service.d
  cat >/etc/systemd/system/hostapd.service.d/override.conf <<EOF
[Unit]
After=dhcpcd.service
Requires=dhcpcd.service
EOF

  systemctl daemon-reexec
  systemctl daemon-reload
  systemctl enable hostapd
  systemctl restart hostapd
}

########################################
# nftables (NAT + firewall)
########################################
configure_nftables() {
  log "Configuring nftables"
  # Common useful ports (from docker-compose services)
  # TCP: SSH, DNS, HTTP, HTTPS, Grafana, ntopng, InfluxDB
  local TCP_PORTS=(22 53 80 443 3000 3002 8086)
  # UDP: DNS, DHCP, NTP
  local UDP_PORTS=(53 67 123)

  # convert arrays to nft-style lists: { 22, 53, 80 }
  local tcp_list
  local udp_list
  tcp_list="{ $(IFS=, ; echo "${TCP_PORTS[*]}") }"
  udp_list="{ $(IFS=, ; echo "${UDP_PORTS[*]}") }"

  # If ALLOW_WAN_PORTS is set (true/1), allow the same ports from WAN as from LAN
  local WAN_RULES=""
  if [[ "${ALLOW_WAN_PORTS:-}" == "true" || "${ALLOW_WAN_PORTS:-}" == "1" ]]; then
    WAN_RULES=$(cat <<RULES
    iif "${WAN_IFACE}" udp dport ${udp_list} accept
    iif "${WAN_IFACE}" tcp dport ${tcp_list} accept

RULES
)
  fi

  cat >/etc/nftables.conf <<EOF
#!/usr/sbin/nft -f

flush ruleset

table inet filter {
  chain input {
    type filter hook input priority 0;
    policy drop;

    iif lo accept
    ct state established,related accept
    ip protocol icmp accept

    iif "${LAN_IFACE}" udp dport ${udp_list} accept
    iif "${LAN_IFACE}" tcp dport ${tcp_list} accept

    ${WAN_RULES}

    counter drop
  }

  chain forward {
    type filter hook forward priority 0;
    policy drop;

    ct state established,related accept
    iif "${LAN_IFACE}" oif "${WAN_IFACE}" accept

    counter drop
  }

  chain output {
    type filter hook output priority 0;
    policy accept;
  }
}

table ip nat {
  chain postrouting {
    type nat hook postrouting priority 100;
    oif "${WAN_IFACE}" masquerade
  }
}
EOF

  systemctl enable nftables
  systemctl restart nftables
}

########################################
# Docker iptables Configuration
########################################
configure_docker_iptables() {
  log "Configuring Docker iptables settings"

  # Ensure Docker daemon.json exists and has iptables enabled
  DOCKER_DAEMON_CONFIG="/etc/docker/daemon.json"
  if [[ ! -f "$DOCKER_DAEMON_CONFIG" ]]; then
    log "Creating Docker daemon.json with iptables enabled"
    cat > "$DOCKER_DAEMON_CONFIG" <<EOF
{
  "iptables": true
}
EOF
  else
    log "Ensuring iptables is enabled in Docker daemon.json"
    if ! grep -q '"iptables": true' "$DOCKER_DAEMON_CONFIG"; then
      sed -i 's/}/,\n  "iptables": true\n}/' "$DOCKER_DAEMON_CONFIG"
    fi
  fi

  # Ensure iptables is in legacy mode
  log "Setting iptables to legacy mode"
  update-alternatives --set iptables /usr/sbin/iptables-legacy
  update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy

  # Create DOCKER-FORWARD chain if missing
  log "Ensuring DOCKER-FORWARD chain exists"
  iptables -C FORWARD -o docker0 -j DOCKER-FORWARD 2>/dev/null || {
    iptables -N DOCKER-FORWARD 2>/dev/null || log "DOCKER-FORWARD chain already exists, continuing..."
  }
  iptables -C FORWARD -o docker0 -j DOCKER-FORWARD 2>/dev/null || iptables -A FORWARD -o docker0 -j DOCKER-FORWARD
  iptables -C FORWARD -i docker0 -j DOCKER-FORWARD 2>/dev/null || iptables -A FORWARD -i docker0 -j DOCKER-FORWARD

  # Restart Docker to apply changes
  log "Restarting Docker"
  systemctl restart docker
}

########################################
# Docker stack
########################################
deploy_stack() {
  log "Deploying Docker stack"
  cd "$REPO_DIR"
  docker compose pull
  docker compose up -d
}

########################################
# Pi-hole FTL
########################################
restart_pihole() {
  log "Reloading Pi-hole DNS"

  # Wait for the Pi-hole container to be healthy
  local retries=12
  while [[ $retries -gt 0 ]]; do
    if docker inspect -f '{{.State.Health.Status}}' pihole 2>/dev/null | grep -q "healthy"; then
      log "Pi-hole container is healthy"
      break
    else
      log "Waiting for Pi-hole container to become healthy..."
      ((retries--))
      sleep 10
    fi
  done

  if [[ $retries -eq 0 ]]; then
    log "ERROR: Pi-hole container did not become healthy"
    exit 1
  fi

  # Reload DNS inside the Pi-hole container
  if ! docker exec pihole pihole enable; then
    log "ERROR: Failed to enable Pi-hole"
    exit 1
  fi
  if ! docker exec pihole pihole reloaddns; then
    log "ERROR: Failed to reload Pi-hole DNS"
    exit 1
  fi
}

########################################
# Main
########################################
main() {
  install_packages
  disable_conflicting_services
  install_docker
  enable_ip_forwarding
  validate_env
  configure_dhcpcd
  configure_hostapd
  configure_nftables
  configure_docker_iptables  # Added this step
  configure_host_dhcp
  deploy_stack
  restart_pihole

  log "Setup complete. Reboot recommended."
}

main "$@"
